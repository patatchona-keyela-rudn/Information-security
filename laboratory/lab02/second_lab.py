# -*- coding: utf-8 -*-
"""second Lab.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1KwAgn5tFCfGTKRWE6cxGlsbP5BNo5qxP

# Задача № 1 Маршрутное шифрование
"""

# Мы принимаем пароль и текст на шрифрование
password = str(input('Введите пароль:'))
my_word = ''.join(str(input('Введите фразу:')).split())

# Длина прямоугольника
n = len(password)
# Дополняем если нужно
if len(my_word)%n != 0:
    my_word += 'a'*(n-len(my_word) % n)

# Отсортируем буквуы пароля
password_sort = ''.join(sorted(password))
index_list = []
for i in range (len(password)):
    f_index = password.find(password_sort[i])
    index_list.append(f_index)

# Шифруем наш текст
new_word = ''
for i in index_list:
    for j in range(len(my_word)//n):
        new_word += my_word[j*n+i]

# Выводим отшифрованный текст
print(new_word)

"""# Задача № 2 Шифрование с помощью решеток"""

import numpy as np

# We enter to word to encode
word_to_encode = list(''.join(input().split()).upper())
print(word_to_encode)

# wE DEFINE THE VALUE OF K: 4k**2 = N
if int(np.sqrt(len(word_to_encode)/4)) == np.sqrt(len(word_to_encode)/4):
  k = int(np.sqrt(len(word_to_encode)/4))
else:
  # wE FILL THE EMPTY POSITIONS WITH STARS
  k = int(np.sqrt(len(word_to_encode)/4)) + 1
  word_to_encode += ['*']*(4 * k**2 - len(word_to_encode))  
print(word_to_encode)

# Simple matrix of k * k
k_matrix = np.reshape(np.arange(k**2),(k,k))
print(k_matrix,'\n')

# Complete matrix: 
full_matrix = np.concatenate((np.concatenate((k_matrix,np.rot90(k_matrix,-1)),axis=1),
                              np.concatenate((np.rot90(k_matrix,-3),np.rot90(k_matrix,-2)),axis=1)
                              ),axis=0)
print(full_matrix)

full_matrix_1d = full_matrix.flatten()
print(full_matrix_1d)
slovar = {}
for i in range(k**2):
  slovar[i] = np.where(full_matrix_1d==i)[0]
print('Dictionary: ',slovar)

# WE RANDOMLY CHOOSE OUR NUMBERS
positions = []
pos = 0
for i in range(k**2):
  pos = np.random.choice(slovar[i])
  positions.append((pos // (2*k) ,pos % (2*k)))
print(positions)

# IN THIS PART WE CREATE AND 
# COMPUTE IT
encoding_matrix = np.zeros((2*k,2*k),dtype=int)
tmp1 = np.zeros((2*k,2*k),dtype=int)
tmp2 = np.zeros((2*k,2*k),dtype=int)
tmp3 = np.zeros((2*k,2*k),dtype=int)
i = 0
for x, y in positions:
  encoding_matrix[x,y] = i
  tmp1[x,y] = i + k**2
  tmp2[x,y] = i + 2*k**2
  tmp3[x,y] = i + 3*k**2
  i += 1
print(encoding_matrix)

# WE ADD ROTATED MATRIX
encoding_matrix += np.rot90(tmp1,-1)
print(encoding_matrix)
encoding_matrix += np.rot90(tmp2,-2)
print(encoding_matrix)
encoding_matrix += np.rot90(tmp3,-3)
print(encoding_matrix)

print(encoding_matrix)

# WE GET THE PASSWORD AND 
# wE CHECK IF IT'S CORRECT
good_password = False
while not good_password:
  password = input(f'Enter a password of {2*k} characters: ')
  if len(password) == 2*k:
    good_password = True

# We get the order of the letters in the password
chars, index = np.unique(list(password),return_index=True)
print(chars,index)

# ENCODING OUR MESSAGE USING
# THE ORDER GOT FROM THE PASSWORD
encoded_text = ''
for col in index:
  for row in range(2*k):
    encoded_text += word_to_encode[2*k*row + col]

print(encoded_text)

"""# Задача № 3 Таблица Виженера"""

slovar = 'абвгдеёжзийклмнопрстуфхцчшщъыьэюя'
password = str(input('Введите пароль: ')).lower()
word = str(input('Введите фразу для шифрования: ')).lower()
k = (len(word) % len(password)) # Количество символов которые нужно дополнить
password_len = '' + password * (len(word) // len(password)) + password[:k]
print(word, password_len, sep='\n')
slovar_visinera = []
slovar_i = 'абвгдеёжзийклмнопрстуфхцчшщъыьэюя'
for i in range(len(slovar)):
    slovar_visinera.append(slovar_i)
    new = slovar_i[1:] + slovar_i[0]
    slovar_i = new
print("Квадрат вижинера:", slovar_visinera)
message = ''
for i in range(len(word)):
    f_index1 = slovar.find(word[i])
    f_index2 = slovar.find(password_len[i])
    message += slovar_visinera[f_index1][f_index2]
print(f'Защифрованное сообщение: {message}')